
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    use epoll;
    worker_connections 8192;
    multi_accept on;
    accept_mutex off;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    server_tokens off;
    proxy_hide_header X-Powered-By;
    proxy_hide_header Server;

    # HTTP和TCP优化
    keepalive_timeout 10; #给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接
    keepalive_requests 1024;#限制了一个 HTTP 长连接最多可以处理完成的最大请求数, 默认是 100。当连接处理完成的请求数达到最大请求数后，将关闭连接。
    tcp_nopush on; #在一个数据包里发送所有头文件，而不一个接一个的发送
    tcp_nodelay on; #nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。

    # Buffers size优化
    client_body_buffer_size  128k; #处理客户端缓冲区大小。 大多数客户端缓冲区都来自POST方法表单提交。128k通常是此设置的不错选择。
    client_max_body_size  256m; #置最大body缓冲区大小。如果请求中的大小超过配置的值，则会将413（请求实体过大）错误返回给客户端。 不过浏览器无法正确显示413错误。 将大小设置为0将禁用对客户机请求正文大小的检查
    client_header_buffer_size    1k; #处理客户端头大小。 默认情况下，1k通常是一个合理的选择。
    large_client_header_buffers  4 4k; #设置客户端头的缓冲区的最大数量和大小。 4个报头与4k缓冲区应该足够了。
    output_buffers  1 32k; #置用于从磁盘读取响应的缓冲区的数量和大小。 如果可能，客户端数据的传输将被推迟，直到Nginx至少具有要发送的数据的字节数的集合大小。零值禁止推迟数据传输。
    postpone_output  1460; #指定Nginx发送给客户端最小的数值，如果可能的话，没有数据会发送，直到达到此值

    # 超时
    client_header_timeout 10; #设置请求头超时时间，建议低
    client_body_timeout 10; #请求体(各自)的超时时间
    reset_timedout_connection on; #关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间
    send_timeout 10; #指定客户端的响应超时时间

    # 静态资源服务
    sendfile            on; #sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile)
    open_file_cache max=100000 inactive=20s; #打开缓存的同时也指定了缓存最大数目，以及缓存的时间
    open_file_cache_valid 30s; #在open_file_cache中指定检测正确信息的间隔时间
    open_file_cache_min_uses 2; #定义了open_file_cache中指令参数不活动时间期间里最小的文件数
    open_file_cache_errors on; #指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件

    #Gzip压缩内容
    gzip on;
    gzip_disable "msie6"; #低版本兼容
    gzip_vary on;
    gzip_proxied any; #允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求
    gzip_static on; #告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源
    gzip_comp_level 6; #压缩级别,1-10越高越消耗CPU，但是压缩越好
    gzip_min_length 1100; #设置对数据启用压缩的最少字节数
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # 其他优化
    limit_conn_zone $binary_remote_addr zone=addr:5m; #设置用于保存各种key（比如当前连接数）的共享内存的参数。5m就是5兆字节，这个值应该被设置的足够大以存储（32K*5）32byte状态或者（16K*5）64byte状态。
    limit_conn addr 100; #给定的key设置最大连接数。这里key是addr，我们设置的值是100，也就是说我们允许每一个IP地址最多同时打开有100个连接。

    proxy_connect_timeout 300;
    proxy_read_timeout 300;
    proxy_send_timeout 300;
    proxy_buffer_size 64k;
    proxy_buffers   4 32k;
    proxy_busy_buffers_size 64k;
    proxy_temp_file_write_size 64k;

    fastcgi_buffers 256 16k;
    fastcgi_buffer_size 128k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_connect_timeout 120s;
    fastcgi_send_timeout 120s;
    fastcgi_read_timeout 120s;

    server_names_hash_bucket_size 100;
    types_hash_max_size 2048;

    uwsgi_ignore_client_abort on;

    include /etc/nginx/conf.d/*.conf;
}